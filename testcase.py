import anthropic
import webbrowser
import subprocess
import urllib.parse
import sys
import os
import json
from PyQt6.QtWidgets import QApplication, QTextEdit, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QSplitter, QLabel, QComboBox, QTreeWidget, QTreeWidgetItem, QPushButton, QInputDialog, QMessageBox, QDialog, QFormLayout, QLineEdit, QComboBox, QCheckBox, QPushButton, QCompleter, QScrollArea, QFrame, QVBoxLayout, QGridLayout, QFileDialog, QDialogButtonBox
from PyQt6.QtCore import Qt, pyqtSignal
import uuid
from datetime import datetime

class SetPathsDialog(QDialog):
    def __init__(self, parent=None, obs_vault_path=None, obs_cd_path=None):
        super().__init__(parent)
        self.setWindowTitle("Set Paths")
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        # Vault Path Button
        self.vault_button = QPushButton("Set Vault Path")
        self.vault_button.clicked.connect(self.set_vault_path)
        self.layout.addWidget(self.vault_button)

        # CD Path Button
        self.cd_button = QPushButton("Set CD Path")
        self.cd_button.clicked.connect(self.set_cd_path)
        self.layout.addWidget(self.cd_button)

        # OK Button to save paths
        self.ok_button = QPushButton("OK")
        self.ok_button.clicked.connect(self.accept)
        self.layout.addWidget(self.ok_button)

        # Store paths
        self.obs_vault_path = obs_vault_path
        self.obs_cd_path = obs_cd_path

    def set_vault_path(self):
        directory = QFileDialog.getExistingDirectory(self, "Select Obsidian Vault Directory", self.obs_vault_path or "")
        if directory:
            self.obs_vault_path = directory

    def set_cd_path(self):
        directory = QFileDialog.getExistingDirectory(self, "Select Obsidian CD Directory", self.obs_cd_path or "")
        if directory:
            self.obs_cd_path = directory

class AddVulnGroupDialog(QDialog):
    vuln_group_added = pyqtSignal(dict)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Vulnerability Group")
        self.layout = QFormLayout()

        # Inputs
        self.group_name = QLineEdit()

        # Buttons
        self.btn_ok = QPushButton("OK")
        self.btn_ok.clicked.connect(self.accept_input)
        self.btn_cancel = QPushButton("Cancel")
        self.btn_cancel.clicked.connect(self.reject)

        # Add to layout
        self.layout.addRow("Group Name:", self.group_name)
        self.layout.addRow(self.btn_ok, self.btn_cancel)
        self.setLayout(self.layout)

    def accept_input(self):
        group = {
            "uuid": str(uuid.uuid4()),  # Generate unique UUID
            "creation_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),  # Capture current date and time
            "group_name": self.group_name.text()
        }
        self.vuln_group_added.emit(group)
        self.accept()

class AddTestCaseDialog(QDialog):
    test_case_added = pyqtSignal(dict)

    def __init__(self, vuln_groups, set_vault_path, parent=None, asset_data=None, otc_patterns=None):
        super().__init__(parent)
        self.setWindowTitle("Add Test Case")
        self.layout = QFormLayout()
        self.set_vault_path = set_vault_path

        # Inputs
        self.title = QComboBox()
        self.title.setEditable(True)
        if otc_patterns:
            self.title.addItems(otc_patterns)
            # Set completer for the combobox
            completer = QCompleter(otc_patterns)
            completer.setFilterMode(Qt.MatchFlag.MatchContains)
            completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
            self.title.setCompleter(completer)
        else:
            self.title.addItem("No OTC patterns found")

        # Connect title change to update technique dropdown
        self.title.currentIndexChanged.connect(self.update_technique_dropdown)

        # Technique dropdown
        self.technique = QComboBox()
        self.location = QLineEdit()
        self.comment = QLineEdit()
        self.status = QComboBox()
        self.status.addItems(["Not started", "Ongoing", "Pass", "Fail"])

        self.exported = QCheckBox()
        self.high_priority = QCheckBox()

        # Vuln Group field
        self.vuln_group = QComboBox()
        self.vuln_group.addItem("Select Vuln Group")
        for group in vuln_groups:
            self.vuln_group.addItem(group['group_name'], group['uuid'])

        # Target Type field
        self.target_type = QComboBox()
        self.target_type.addItems(["Module", "URL", "IP", "Service", "File path"])

        # Target Name field
        self.target_name = QLineEdit()

        # Target Value field
        self.target_value = QLineEdit()

        # Buttons
        self.btn_ok = QPushButton("OK")
        self.btn_ok.clicked.connect(self.accept_input)
        self.btn_cancel = QPushButton("Cancel")
        self.btn_cancel.clicked.connect(self.reject)

        # Add to layout
        self.layout.addRow("Title:", self.title)
        self.layout.addRow("Technique:", self.technique)
        self.layout.addRow("Target Type:", self.target_type)
        self.layout.addRow("Target Name:", self.target_name)
        self.layout.addRow("Target Value:", self.target_value)
        self.layout.addRow("Location:", self.location)
        self.layout.addRow("Comment:", self.comment)
        self.layout.addRow("Status:", self.status)
        self.layout.addRow("Exported:", self.exported)
        self.layout.addRow("High-Priority:", self.high_priority)
        self.layout.addRow("Vuln Group:", self.vuln_group)
        self.layout.addRow(self.btn_ok, self.btn_cancel)
        self.setLayout(self.layout)

        # Pre-fill fields if asset data is provided
        if asset_data:
            asset_type = asset_data.get('type', '')
            asset_name = asset_data.get('name', '')
            asset_value = asset_data.get('value', '')
            if asset_type:
                index = self.target_type.findText(asset_type)
                if index != -1:
                    self.target_type.setCurrentIndex(index)
                else:
                    self.target_type.setCurrentText(asset_type)
            if asset_name:
                self.target_name.setText(asset_name)
            if asset_value:
                self.target_value.setText(asset_value)

        # Initialize technique dropdown
        self.update_technique_dropdown()

    def search_file(self):
        selected_title = self.title.currentText()
        if not selected_title:
            return []
        file_name = f"{selected_title}.md"
        headings = []
        for root, dirs, files in os.walk(self.set_vault_path):
            if file_name in files:
                md_note_file_path = os.path.join(root, file_name).replace("\\", "/")
                if os.path.exists(md_note_file_path):
                    inside_techniques = False
                    inside_code_block = False
                    code_block_lines = []
                    with open(md_note_file_path, "r", encoding="utf-8") as file:
                        for line in file:
                            line = line.strip()
                            if line.startswith("##") and line.lower() == "## techniques":
                                inside_techniques = True
                                continue
                            elif inside_techniques and line.startswith("```"):
                                if inside_code_block:
                                    # End of the code block
                                    break
                                else:
                                    # Start of the code block
                                    inside_code_block = True
                                    continue
                            elif inside_techniques and inside_code_block:
                                code_block_lines.append(line)
                            elif line.startswith("##") and inside_techniques:
                                # Exiting "## Techniques" section
                                break
                    return code_block_lines
        return []

    def update_technique_dropdown(self):
        headings = self.search_file()
        self.technique.clear()
        if headings:
            self.technique.addItems(headings)
        else:
            self.technique.addItem("No techniques found")

    def accept_input(self):
        test_case = {
            "uuid": str(uuid.uuid4()),
            "creation_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "title": self.title.currentText(),
            "technique": self.technique.currentText(),
            "target_type": self.target_type.currentText(),
            "target_name": self.target_name.text(),
            "target_value": self.target_value.text(),
            "location": self.location.text(),
            "comment": self.comment.text(),
            "status": self.status.currentText(),
            "exported": self.exported.isChecked(),
            "high_priority": self.high_priority.isChecked(),
            "vuln_group_uuid": self.vuln_group.currentData(),
        }
        self.test_case_added.emit(test_case)
        self.accept()

class AddMultipleTestCasesDialog(QDialog):
    test_cases_selected = pyqtSignal(list)

    def __init__(self, otc_patterns, set_vault_path, parent=None, vuln_groups=None, asset_data=None):
        super().__init__(parent)
        self.setWindowTitle("Add Multiple Test Cases")
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        self.set_vault_path = set_vault_path
        self.vuln_groups = vuln_groups
        self.asset_data = asset_data  # Store asset_data

        # Create a scroll area to hold test case items
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout()
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)

        # Populate the scroll area with test case items
        self.test_case_items = []
        for pattern in otc_patterns:
            self.add_test_case_item(pattern)

        # OK button to confirm selection
        self.btn_ok = QPushButton("OK")
        self.btn_ok.clicked.connect(self.accept_input)
        self.layout.addWidget(self.btn_ok)

    def add_test_case_item(self, title):
        container = QWidget()
        layout = QHBoxLayout()
        container.setLayout(layout)

        checkbox = QCheckBox(title)
        layout.addWidget(checkbox)

        # Fetch techniques for the title
        techniques = self.get_techniques_for_title(title)
        technique_combo = QComboBox()
        technique_combo.addItems(techniques)
        layout.addWidget(technique_combo)

        self.test_case_items.append({'checkbox': checkbox, 'technique': technique_combo})
        self.scroll_layout.addWidget(container)

    def get_techniques_for_title(self, title):
        if not title or not self.set_vault_path:
            return []
        file_name = f"{title}.md"
        techniques = []
        for root, dirs, files in os.walk(self.set_vault_path):
            if file_name in files:
                md_note_file_path = os.path.join(root, file_name).replace("\\", "/")
                if os.path.exists(md_note_file_path):
                    inside_techniques = False
                    inside_code_block = False
                    with open(md_note_file_path, "r", encoding="utf-8") as file:
                        for line in file:
                            line = line.strip()
                            if line.startswith("##") and line.lower() == "## techniques":
                                inside_techniques = True
                                continue
                            elif inside_techniques and line.startswith("```"):
                                if inside_code_block:
                                    break
                                else:
                                    inside_code_block = True
                                    continue
                            elif inside_techniques and inside_code_block:
                                techniques.append(line)
                            elif line.startswith("##") and inside_techniques:
                                break
                    return techniques
        return []

    def accept_input(self):
        selected_test_cases = []
        for item in self.test_case_items:
            if item['checkbox'].isChecked():
                test_case = {
                    "uuid": str(uuid.uuid4()),
                    "creation_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "title": item['checkbox'].text(),
                    "technique": item['technique'].currentText(),
                    "target_type": self.asset_data.get('type', '') if self.asset_data else "",
                    "target_name": self.asset_data.get('name', '') if self.asset_data else "",
                    "target_value": self.asset_data.get('value', '') if self.asset_data else "",
                    "location": "",
                    "comment": "",
                    "status": "Not started",
                    "exported": False,
                    "high_priority": False,
                    "vuln_group_uuid": ""
                }
                selected_test_cases.append(test_case)
        self.test_cases_selected.emit(selected_test_cases)
        self.accept()

class AssetItemWidget(QWidget):
    def __init__(self, asset_name, asset_data, parent_widget, scope_widget):
        super().__init__()
        self.asset_name = asset_name
        self.asset_data = asset_data  # Should contain 'uuid', 'name', 'type'
        self.parent_widget = parent_widget  # Reference to MainWindow
        self.scope_widget = scope_widget  # Reference to ScopeItemWidget
        self.asset_uuid = asset_data.get('uuid', None)  # Store asset UUID

        layout = QHBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.setLayout(layout)

        self.label = QLabel(f"{self.asset_name}")
        layout.addWidget(self.label)

        self.add_button = QPushButton(" + TC ")
        self.add_button.setFixedWidth(50)  # Set a fixed width for the button
        self.add_button.clicked.connect(self.add_test_case)
        layout.addWidget(self.add_button)

        # Add +MTC button
        self.add_mtc_button = QPushButton(" +MTC ")
        self.add_mtc_button.setFixedWidth(50)
        self.add_mtc_button.clicked.connect(self.add_multiple_test_cases)
        layout.addWidget(self.add_mtc_button)

        self.setFixedHeight(24)

    def save_multiple_test_cases(self, test_cases):
        project_data = self.parent_widget.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            testcase_path = os.path.join(project_path, "testcase_details.json")
            # Read existing test cases
            if os.path.exists(testcase_path):
                with open(testcase_path, 'r') as json_file:
                    testcases = json.load(json_file)
            else:
                testcases = {}

            if self.asset_uuid:
                if self.asset_uuid not in testcases:
                    testcases[self.asset_uuid] = []
                for test_case in test_cases:
                    # Initialize the completed field based on the initial status
                    test_case['completed'] = test_case['status'] in ['Pass', 'Fail']
                    testcases[self.asset_uuid].append(test_case)
                # Save the updated test cases
                with open(testcase_path, 'w') as json_file:
                    json.dump(testcases, json_file, indent=4)
                QMessageBox.information(self, "Success", "Test cases added successfully.")
                self.parent_widget.load_test_cases(self.asset_uuid)
            else:
                QMessageBox.warning(self, "Error", "Asset UUID not found.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def add_multiple_test_cases(self):
        project_data = self.parent_widget.project_dropdown.currentData()
        project_path = self.parent_widget.get_project_path(project_data)

        if project_path:
            config_path = os.path.join(project_path, "obsidian_config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as config_file:
                    config = json.load(config_file)
                    set_vault_path = config.get("obs_vault_path", "")
            else:
                set_vault_path = None
        else:
            set_vault_path = None

        if project_path:
            issues_path = os.path.join(project_path, "issues.json")
            if os.path.exists(issues_path):
                with open(issues_path, 'r') as json_file:
                    vuln_groups = json.load(json_file)
            else:  # Correctly aligned with its corresponding if
                vuln_groups = []

            # Get OTC patterns from the selected file in the scope dropdown
            otc_patterns = self.get_otc_patterns(project_path)
            if otc_patterns is None:
                otc_patterns = []

            # Create the dialog to select multiple test cases, passing the asset_data
            dialog = AddMultipleTestCasesDialog(
                otc_patterns, 
                set_vault_path, 
                self, 
                vuln_groups, 
                asset_data=self.asset_data  # Pass the asset_data here
            )
            dialog.test_cases_selected.connect(self.save_multiple_test_cases)
            dialog.exec()
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")


    def add_test_case(self):
        project_data = self.parent_widget.project_dropdown.currentData()
        project_path = self.parent_widget.get_project_path(project_data)

        if project_path:
            config_path = os.path.join(project_path, "obsidian_config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as config_file:
                    config = json.load(config_file)
                    set_vault_path = config.get("obs_vault_path", "")
            else:
                set_vault_path = None
        else:
            set_vault_path = None

        if project_path:
            issues_path = os.path.join(project_path, "issues.json")
            if os.path.exists(issues_path):
                with open(issues_path, 'r') as json_file:
                    vuln_groups = json.load(json_file)

                # Get OTC patterns from the selected file in the scope dropdown
                otc_patterns = self.get_otc_patterns(project_path)
                if otc_patterns is None:
                    otc_patterns = []

                # Create the dialog with OTC patterns
                dialog = AddTestCaseDialog(vuln_groups, set_vault_path, self, asset_data=self.asset_data, otc_patterns=otc_patterns)
                dialog.test_case_added.connect(self.save_test_case)
                dialog.exec()
            else:
                QMessageBox.warning(self, "Error", "Issues file not found.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def get_otc_patterns(self, project_path):
        selected_scope_item = self.scope_widget.dropdown.currentText()
        if selected_scope_item:
            config_path = os.path.join(project_path, "obsidian_config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as config_file:
                    config = json.load(config_file)
                    obs_cd_path = config.get("obs_cd_path", "")
                    if obs_cd_path:
                        selected_file = self.scope_widget.dropdown.currentText()
                        file_path = os.path.join(obs_cd_path, selected_file)
                        if os.path.exists(file_path):
                            with open(file_path, 'r', encoding='utf-8') as file:
                                content = file.read()
                                import re
                                otc_patterns = re.findall(r'\[\[(.*?)\]\]', content)
                                return otc_patterns
                        else:
                            QMessageBox.warning(self, "Error", "File not found.")
                            return None
                    else:
                        QMessageBox.warning(self, "Error", "Obsidian vault path not set.")
                        return None
            else:
                QMessageBox.warning(self, "Error", "Obsidian config file not found.")
                return None
        else:
            QMessageBox.warning(self, "Error", "No file selected in the dropdown.")
            return None

    def save_test_case(self, test_case):
        project_data = self.parent_widget.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            testcase_path = os.path.join(project_path, "testcase_details.json")
            # Read existing test cases
            if os.path.exists(testcase_path):
                with open(testcase_path, 'r') as json_file:
                    testcases = json.load(json_file)
            else:
                testcases = {}

            if self.asset_uuid:
                if self.asset_uuid not in testcases:
                    testcases[self.asset_uuid] = []
                # Initialize the completed field based on the initial status
                test_case['completed'] = test_case['status'] in ['Pass', 'Fail']
                testcases[self.asset_uuid].append(test_case)
                # Save the updated test cases
                with open(testcase_path, 'w') as json_file:
                    json.dump(testcases, json_file, indent=4)
                QMessageBox.information(self, "Success", "Test case added successfully.")
                self.parent_widget.load_test_cases(self.asset_uuid)
            else:
                QMessageBox.warning(self, "Error", "Asset UUID not found.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def get_project_path(self, project_data):
        projects_dir = "projects"
        project_name = project_data.get("project_name")
        for project_dir in os.listdir(projects_dir):
            project_path = os.path.join(projects_dir, project_dir)
            if os.path.isdir(project_path) and os.path.exists(os.path.join(project_path, "project_details.json")):
                with open(os.path.join(project_path, "project_details.json"), 'r') as json_file:
                    data = json.load(json_file)
                    if data.get("project_name") == project_name:
                        return project_path
        return None

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("Project Viewer")
        self.setGeometry(100, 100, 800, 600)
        self.showMaximized()

        # Ensure required files are created
        self.create_required_files()

        main_layout = QVBoxLayout()

        # Define field labels with proper names
        self.field_labels = {
            "title": "Title",
            "technique": "Technique",
            "target_type": "Target Type",
            "target_name": "Target Name",
            "target_value": "Target Value",
            "location": "Location",
            "comment": "Comment",
            "status": "Status",
            "exported": "Exported",
            "high_priority": "High-Priority",
            "vuln_group_uuid": "Vuln Group",
            # Add other fields as needed
        }

        # Define the order of the fields
        self.field_order = [
            "title",
            "technique",
            "target_type",
            "target_name",
            "target_value",
            "location",
            "comment",
            "status",
            "exported",
            "high_priority",
            "vuln_group_uuid"
        ]

        # Initialize STC variables
        self.stc_active = False
        self.uuid_list = []
        self.current_file_number = 1
        self.timestamp_dir = None

        self.top_section = QWidget()
        top_layout = QHBoxLayout()
        self.top_section.setLayout(top_layout)

        self.project_dropdown = QComboBox()
        self.project_dropdown.currentIndexChanged.connect(self.load_project_details)
        top_layout.addWidget(self.project_dropdown)

        self.add_vuln_group_button = QPushButton("Add Vuln Group")
        self.add_vuln_group_button.clicked.connect(self.add_vuln_group)
        top_layout.addWidget(self.add_vuln_group_button)

        self.set_obs_checklist_dir_path_button = QPushButton("Set Obs CD Path")
        self.set_obs_checklist_dir_path_button.clicked.connect(self.set_obs_checklist_dir_path)
        top_layout.addWidget(self.set_obs_checklist_dir_path_button)

        # Add the new button to open project details directory
        self.open_project_dir_button = QPushButton("Open Project Dir")
        self.open_project_dir_button.clicked.connect(self.open_project_dir)
        top_layout.addWidget(self.open_project_dir_button)

        # Add the reload button
        self.reload_button = QPushButton("Reload")
        self.reload_button.clicked.connect(self.reload_app)
        top_layout.addWidget(self.reload_button)

        # Add the new button to open project management
        self.project_management_button = QPushButton("Open PM")
        self.project_management_button.clicked.connect(self.run_project_management)
        top_layout.addWidget(self.project_management_button)

        # Add the "STC" button
        self.stc_button = QPushButton("Extract TC")
        self.stc_button.setCheckable(True)  # Make it a toggle button
        self.stc_button.clicked.connect(self.toggle_stc)
        self.stc_active = False  # Initialize STC state
        top_layout.addWidget(self.stc_button)

        self.get_updates_button = QPushButton("Write Updates")
        self.get_updates_button.clicked.connect(self.on_get_updates_clicked)
        top_layout.addWidget(self.get_updates_button)

        self.stc_counter_label = QLabel("")
        top_layout.addWidget(self.stc_counter_label)

        self.bottom_section = QWidget()
        bottom_layout = QHBoxLayout()
        self.bottom_section.setLayout(bottom_layout)

        self.left_section = QWidget()
        left_layout = QVBoxLayout()
        self.left_section.setLayout(left_layout)

        self.right_section = QWidget()
        right_layout = QVBoxLayout()
        self.right_section.setLayout(right_layout)

        self.project_tree = QTreeWidget()
        self.project_tree.setHeaderHidden(True)
        self.project_tree.itemClicked.connect(self.load_asset_test_cases)
        left_layout.addWidget(self.project_tree)

        self.current_filter_status = "All"  # Initialize the current filter status
        self.current_title_filter = "All"  # Initialize the current title filter
        self.is_updating_filters = False  # flag to prevent recursive calls

        # Add header row
        self.header_row = QWidget()
        header_layout = QHBoxLayout()
        self.header_row.setLayout(header_layout)

        # Add title filter dropdown
        self.title_filter_dropdown = QComboBox()
        self.title_filter_dropdown.addItem("All")
        self.title_filter_dropdown.currentTextChanged.connect(self.filter_test_cases_by_title)
        header_layout.addWidget(self.title_filter_dropdown)

        # Connect filter buttons
        self.all_button = QPushButton("All")
        self.all_button.clicked.connect(lambda: self.set_active_button(self.all_button))
        self.all_button.clicked.connect(lambda: self.filter_test_cases("All"))
        header_layout.addWidget(self.all_button)

        self.not_started_button = QPushButton("Not started")
        self.not_started_button.clicked.connect(lambda: self.set_active_button(self.not_started_button))
        self.not_started_button.clicked.connect(lambda: self.filter_test_cases("Not started"))
        header_layout.addWidget(self.not_started_button)

        self.ongoing_button = QPushButton("Ongoing")
        self.ongoing_button.clicked.connect(lambda: self.set_active_button(self.ongoing_button))
        self.ongoing_button.clicked.connect(lambda: self.filter_test_cases("Ongoing"))
        header_layout.addWidget(self.ongoing_button)

        self.pass_button = QPushButton("Pass")
        self.pass_button.clicked.connect(lambda: self.set_active_button(self.pass_button))
        self.pass_button.clicked.connect(lambda: self.filter_test_cases("Pass"))
        header_layout.addWidget(self.pass_button)

        self.fail_button = QPushButton("Fail")
        self.fail_button.clicked.connect(lambda: self.set_active_button(self.fail_button))
        self.fail_button.clicked.connect(lambda: self.filter_test_cases("Fail"))
        header_layout.addWidget(self.fail_button)

        self.unexported_button = QPushButton("Unexported")
        self.unexported_button.clicked.connect(lambda: self.set_active_button(self.unexported_button))
        self.unexported_button.clicked.connect(lambda: self.filter_test_cases("Unexported"))
        header_layout.addWidget(self.unexported_button)

        right_layout.addWidget(self.header_row)

        self.test_case_scroll_area = QScrollArea()
        self.test_case_scroll_area.setWidgetResizable(True)
        self.test_case_container = QWidget()
        self.test_case_layout = QVBoxLayout()
        self.test_case_container.setLayout(self.test_case_layout)
        self.test_case_scroll_area.setWidget(self.test_case_container)
        right_layout.addWidget(self.test_case_scroll_area)

        self.bottom_splitter = QSplitter(Qt.Orientation.Horizontal)
        self.bottom_splitter.addWidget(self.left_section)
        self.bottom_splitter.addWidget(self.right_section)

        self.main_splitter = QSplitter(Qt.Orientation.Vertical)
        self.main_splitter.addWidget(self.top_section)
        self.main_splitter.addWidget(self.bottom_splitter)

        self.main_splitter.setSizes([10, 550])
        self.bottom_splitter.setSizes([170, 500])

        main_layout.addWidget(self.main_splitter)

        container = QWidget()
        container.setLayout(main_layout)
        self.setCentralWidget(container)

        self.last_modified_times = {}

        self.load_projects()
        self.load_last_clicked_asset()
        self.current_filter_status = "All"  # Initialize with "All"
        self.set_active_button(self.all_button)

    def on_get_updates_clicked(self):
        selected_project_data = self.project_dropdown.currentData()
        if not selected_project_data:
            QMessageBox.warning(self, "Error", "No project selected.")
            return

        project_path = self.get_project_path(selected_project_data)
        if not project_path:
            QMessageBox.warning(self, "Error", "Project path not found.")
            return

        raw_dir = os.path.join(project_path, "updates", "raw")
        if not os.path.exists(raw_dir) or not os.path.isdir(raw_dir):
            QMessageBox.warning(self, "Error", "Raw directory not found.")
            return

        available_dirs = [d for d in os.listdir(raw_dir) if os.path.isdir(os.path.join(raw_dir, d))]
        if not available_dirs:
            QMessageBox.warning(self, "Error", "No directories found in raw.")
            return

        # Dialog to select the directory
        dir_dialog = QDialog(self)
        dir_dialog.setWindowTitle("Select Directory")
        dir_layout = QVBoxLayout()
        dir_dialog.setLayout(dir_layout)

        dir_combobox = QComboBox()
        dir_combobox.addItems(available_dirs)
        dir_layout.addWidget(dir_combobox)

        btn_ok = QPushButton("OK")
        btn_ok.clicked.connect(dir_dialog.accept)
        dir_layout.addWidget(btn_ok)

        if dir_dialog.exec() == QDialog.DialogCode.Accepted:
            selected_dir = dir_combobox.currentText()
            selected_dir_path = os.path.join(raw_dir, selected_dir)
            txt_files = [f for f in os.listdir(selected_dir_path) if f.endswith('.txt')]

            if not txt_files:
                QMessageBox.warning(self, "Error", "No .txt files found in the selected directory.")
                return

            # Dialog to select the prompt file
            prompts_dir = os.path.join("prompts")
            if not os.path.exists(prompts_dir) or not os.path.isdir(prompts_dir):
                QMessageBox.warning(self, "Error", "Prompts directory not found.")
                return

            prompt_files = [f for f in os.listdir(prompts_dir) if f.endswith('.txt')]
            if not prompt_files:
                QMessageBox.warning(self, "Error", "No prompt files found in the prompts directory.")
                return

            prompt_dialog = QDialog(self)
            prompt_dialog.setWindowTitle("Select Prompt")
            prompt_layout = QVBoxLayout()
            prompt_dialog.setLayout(prompt_layout)

            prompt_combobox = QComboBox()
            prompt_combobox.addItems(prompt_files)
            prompt_layout.addWidget(prompt_combobox)

            btn_prompt_ok = QPushButton("OK")
            btn_prompt_ok.clicked.connect(prompt_dialog.accept)
            prompt_layout.addWidget(btn_prompt_ok)

            if prompt_dialog.exec() == QDialog.DialogCode.Accepted:
                selected_prompt_file = prompt_combobox.currentText()
                prompt_path = os.path.join(prompts_dir, selected_prompt_file)
                with open(prompt_path, 'r', encoding='utf-8') as prompt_file:
                    prompt = prompt_file.read().strip()

                # Create "pointers" directory if it doesn't exist
                pointers_dir = os.path.join(project_path, "updates", "pointers")
                if not os.path.exists(pointers_dir):
                    os.makedirs(pointers_dir)

                # Generate filename with date_time and number of test cases
                timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M")
                file_count = len(txt_files)
                output_filename = f"pointers_{timestamp}_testcases_{file_count}.txt"
                output_path = os.path.join(pointers_dir, output_filename)

                with open(output_path, 'w', encoding='utf-8') as output_file:
                    for idx, txt_file in enumerate(txt_files, start=1):
                        file_path = os.path.join(selected_dir_path, txt_file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as file:
                                content = file.read()
                        except Exception as e:
                            QMessageBox.warning(self, "Error", f"Failed to read {txt_file}: {e}")
                            continue

                        # Anonymize URLs and keep mapping
                        import re
                        url_pattern = re.compile(r'https?://[^\s"\'<]+')
                        urls_found = url_pattern.findall(content)
                        anonymized_urls = {}
                        base_anon_url = "https://example{}.com"
                        for i, url in enumerate(urls_found, start=1):
                            anonymized_url = base_anon_url.format(i)
                            anonymized_urls[anonymized_url] = url  # Store mapping
                            content = content.replace(url, anonymized_url)

                        # Process with LLM
                        try:
                            processed_content = self.process_with_anthropic(content, prompt)
                        except Exception as e:
                            QMessageBox.warning(self, "Error", f"Failed to process {txt_file} with LLM: {e}")
                            continue

                        # Replace anonymized URLs with original URLs
                        for anonymized_url, original_url in anonymized_urls.items():
                            processed_content = processed_content.replace(anonymized_url, original_url)

                        # Append to output file
                        output_file.write(processed_content)
                        output_file.write("\n\n")  # Separate processed contents of different files

                        # Open the output file automatically
                        if os.path.exists(output_path):
                            if sys.platform == "win32":
                                os.startfile(output_path)
                            elif sys.platform == "darwin":
                                subprocess.call(["open", output_path])
                            else:
                                subprocess.call(["xdg-open", output_path])

                # QMessageBox.information(self, "Success", f"Processed content saved to {output_path}.")

    def process_with_anthropic(self, content, prompt):
        client = anthropic.Anthropic(api_key=os.environ.get('ANTHROPIC_API_KEY'))
        # Format the prompt with system and user tags
        full_prompt = f"<system>{prompt}</system>\n<user>{content}</user>"

        response = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1000,
            temperature=0,
            messages=[
                {
                    "role": "user",
                    "content": full_prompt
                }
            ]
        )
        processed_content = response.content[0].text

        return processed_content

    def toggle_stc(self):
        self.stc_active = not self.stc_active
        if self.stc_active:
            self.stc_button.setText("Extract TC (On)")
            # Initialize counter
            self.stc_counter = 0
            self.stc_counter_label.setText(f"TC Extracted: {self.stc_counter}")
            # Create timestamped directory
            project_data = self.project_dropdown.currentData()
            project_path = self.get_project_path(project_data)
            if project_path:
                raw_dir = os.path.join(project_path, "updates", "raw")
                if not os.path.exists(raw_dir):
                    os.makedirs(raw_dir)
                # Create timestamped directory
                timestamp = datetime.now().strftime("%Y-%m-%d__%H-%M")
                self.timestamp_dir = os.path.join(raw_dir, timestamp)
                os.makedirs(self.timestamp_dir)
                # Initialize file number and UUID list
                self.current_file_number = 1
                self.uuid_list = []
        else:
            self.stc_button.setText("Extract TC")
            # Save remaining UUIDs
            if self.uuid_list:
                self.save_uuids_to_file()
            # Reset counter
            self.stc_counter = 0
            self.stc_counter_label.setText(f"TC Extracted: {self.stc_counter}")
            # Reset variables
            self.timestamp_dir = None
            self.current_file_number = 1
            self.uuid_list = []

    def filter_test_cases_by_title(self, selected_title):
        if self.is_updating_filters:
            return
        if hasattr(self, 'current_asset_uuid'):
            current_status = getattr(self, 'current_filter_status', 'All')
            if selected_title == "All":
                self.load_test_cases(self.current_asset_uuid, current_status)
            else:
                self.load_test_cases(self.current_asset_uuid, current_status, title_filter=selected_title)

    def run_project_management(self):
        try:
            # Get the directory of the current script
            script_dir = os.path.dirname(os.path.abspath(__file__))
            # Path to the project-management script
            project_management_script = os.path.join(script_dir, "project-management.py")
            # Run the script using the same python interpreter
            subprocess.Popen([sys.executable, project_management_script])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not launch project-management: {e}")

    def set_active_button(self, button):
        # Define color and font-color mapping for each button
        button_styles = {
            self.all_button: ("#add8e6", "black"),  # Light Blue
            self.not_started_button: ("#d3d3d3", "black"),  # Light Gray
            self.ongoing_button: ("#ffffe0", "black"),  # Light Yellow
            self.pass_button: ("#90ee90", "black"),  # Light Green
            self.fail_button: ("#ff7f7f", "white"),  # Light Red
            self.unexported_button: ("#ffcc99", "black")  # Light Orange
        }

        # Deactivate all buttons
        for btn in button_styles.keys():
            btn.setStyleSheet("")

        # Activate the selected button with its specific styles
        if button in button_styles:
            bg_color, font_color = button_styles[button]
            button.setStyleSheet(f"background-color: {bg_color}; color: {font_color};")

        self.current_filter_status = button.text().lower()

    def filter_test_cases(self, status):
        if self.is_updating_filters:
            return
        self.load_test_cases(self.current_asset_uuid, status, self.title_filter_dropdown.currentText())
        self.current_filter_status = status.lower()
        self.update_button_counts()

    def update_button_counts(self):
        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            testcase_path = os.path.join(project_path, "testcase_details.json")
            if os.path.exists(testcase_path):
                with open(testcase_path, 'r') as json_file:
                    testcases = json.load(json_file)
                    if self.current_asset_uuid in testcases:
                        cases = testcases[self.current_asset_uuid]
                        all_count = len(cases)
                        not_started_count = sum(1 for tc in cases if tc["status"] == "Not started")
                        ongoing_count = sum(1 for tc in cases if tc["status"] == "Ongoing")
                        pass_count = sum(1 for tc in cases if tc["status"] == "Pass")
                        fail_count = sum(1 for tc in cases if tc["status"] == "Fail")
                        unexported_count = sum(1 for tc in cases if (tc["status"] in ["Pass", "Fail"]) and not tc["exported"])

                        self.all_button.setText(f"All ({all_count})")
                        self.not_started_button.setText(f"Not started ({not_started_count})")
                        self.ongoing_button.setText(f"Ongoing ({ongoing_count})")
                        self.pass_button.setText(f"Pass ({pass_count})")
                        self.fail_button.setText(f"Fail ({fail_count})")
                        self.unexported_button.setText(f"Unexported ({unexported_count})")

    def reload_app(self):
        # Reload projects and project details
        self.load_projects()
        self.load_project_details()
        # Optionally reload other components if needed
        self.load_last_clicked_asset()
        # QMessageBox.information(self, "Reload", "Project details reloaded.")

    def load_last_clicked_asset(self):
        selected_project_data = self.project_dropdown.currentData()
        if selected_project_data:
            project_path = self.get_project_path(selected_project_data)
            if project_path:
                uuid_str = MainWindow.get_last_uuid_from_log(project_path)
                if uuid_str:
                    asset_item = self.find_asset_item_by_uuid(uuid_str)
                    if asset_item:
                        self.project_tree.expandItem(asset_item.parent())
                        self.project_tree.setCurrentItem(asset_item)
                        
                        # Load test cases for the selected asset
                        asset_widget = self.project_tree.itemWidget(asset_item, 0)
                        if isinstance(asset_widget, AssetItemWidget):
                            asset_uuid = asset_widget.asset_data.get('uuid', None)
                            if asset_uuid:
                                self.load_test_cases(asset_uuid)

    def get_last_uuid_from_log(project_path):
        log_file_path = os.path.join(project_path, "click_log.txt")
        if os.path.exists(log_file_path):
            with open(log_file_path, 'r', encoding='utf-8') as log_file:
                lines = log_file.readlines()
                if lines:
                    last_line = lines[-1].strip()
                    parts = last_line.split(" - UUID: ")
                    if len(parts) > 1:
                        uuid_str = parts[1]
                        return uuid_str
        return None

    def find_asset_item_by_uuid(self, uuid_str):
        root = self.project_tree.invisibleRootItem()
        for i in range(root.childCount()):
            project_item = root.child(i)
            for j in range(project_item.childCount()):
                scope_item = project_item.child(j)
                for k in range(scope_item.childCount()):
                    asset_item = scope_item.child(k)
                    asset_widget = self.project_tree.itemWidget(asset_item, 0)
                    if isinstance(asset_widget, AssetItemWidget):
                        asset_uuid = asset_widget.asset_data.get('uuid', None)
                        if asset_uuid == uuid_str:
                            return asset_item
        return None

    def set_obs_checklist_dir_path(self):
        selected_project_data = self.project_dropdown.currentData()
        if not selected_project_data:
            QMessageBox.warning(self, "Error", "No project selected.")
            return

        project_path = self.get_project_path(selected_project_data)
        if not project_path:
            QMessageBox.warning(self, "Error", "Project path not found.")
            return

        config_path = os.path.join(project_path, "obsidian_config.json")
        config = {}
        if os.path.exists(config_path):
            with open(config_path, 'r') as config_file:
                config = json.load(config_file)

        current_vault_path = config.get("obs_vault_path", "")
        current_cd_path = config.get("obs_cd_path", "")

        dialog = SetPathsDialog(self, current_vault_path, current_cd_path)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Save the paths to the config file
            config["obs_vault_path"] = dialog.obs_vault_path
            config["obs_cd_path"] = dialog.obs_cd_path

            with open(config_path, 'w') as config_file:
                json.dump(config, config_file, indent=4)

            # QMessageBox.information(self, "Success", "Paths set successfully.")
            self.reload_app()

    def create_required_files(self):
        projects_dir = "projects"
        if not os.path.exists(projects_dir):
            os.makedirs(projects_dir)

        for project_dir in os.listdir(projects_dir):
            project_path = os.path.join(projects_dir, project_dir)
            if os.path.isdir(project_path):
                issues_path = os.path.join(project_path, "issues.json")
                testcase_path = os.path.join(project_path, "testcase_details.json")

                if not os.path.exists(issues_path):
                    with open(issues_path, 'w') as json_file:
                        json.dump([], json_file, indent=4)

                if not os.path.exists(testcase_path):
                    with open(testcase_path, 'w') as json_file:
                        json.dump({}, json_file, indent=4)

                updates_dir = os.path.join(project_path, "updates")
                if not os.path.exists(updates_dir):
                    os.makedirs(updates_dir)

                raw_dir = os.path.join(updates_dir, "raw")
                if not os.path.exists(raw_dir):
                    os.makedirs(raw_dir)

    def open_project_dir(self):
        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            if sys.platform == "win32":
                os.startfile(project_path)
            elif sys.platform == "darwin":
                subprocess.call(["open", project_path])
            else:
                subprocess.call(["xdg-open", project_path])
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def load_projects(self):
        projects_dir = "projects"
        if not os.path.exists(projects_dir):
            return

        self.project_dropdown.clear()
        self.last_modified_times.clear()

        for project_dir in os.listdir(projects_dir):
            project_path = os.path.join(projects_dir, project_dir)
            if os.path.isdir(project_path):
                json_file_path = os.path.join(project_path, "project_details.json")
                if os.path.exists(json_file_path):
                    with open(json_file_path, 'r') as json_file:
                        project_data = json.load(json_file)
                        # Ensure each scope has "selected_file"
                        for scope in project_data["scopes"]:
                            if "selected_file" not in scope:
                                scope["selected_file"] = ""
                        self.project_dropdown.addItem(project_data["project_name"], project_data)

    def load_project_details(self):
        self.project_tree.clear()
        selected_project_data = self.project_dropdown.currentData()
        if selected_project_data:
            project_item = QTreeWidgetItem(self.project_tree, [f"Project: {selected_project_data['project_name']}"])
            for scope in selected_project_data["scopes"]:
                if scope['name'] == "-":
                    scope_name = f"{scope['type']}: {scope['value']}"
                else:
                    scope_name = f"{scope['type']} ({scope['name']}) {scope['value']}"
                scope_widget = ScopeItemWidget(scope_name, scope, self)
                scope_item = QTreeWidgetItem(project_item)
                self.project_tree.setItemWidget(scope_item, 0, scope_widget)
                scope_item.setSizeHint(0, scope_widget.sizeHint())
                # Add assets under the scope
                for asset in scope["assets"]:
                    if asset['name'] == "-":
                        asset_widget = AssetItemWidget(asset['type']+': '+asset['value'], asset, self, scope_widget)
                    else:
                        asset_widget = AssetItemWidget(asset['type']+' ['+asset['name']+']', asset, self, scope_widget)
                    asset_item = QTreeWidgetItem(scope_item)
                    self.project_tree.setItemWidget(asset_item, 0, asset_widget)
                    asset_item.setSizeHint(0, asset_widget.sizeHint())
            self.project_tree.expandAll()

    def load_asset_test_cases(self, item, column):
        asset_widget = self.project_tree.itemWidget(item, column)
        if isinstance(asset_widget, AssetItemWidget):
            asset_uuid = asset_widget.asset_data.get('uuid', None)
            if asset_uuid:
                self.load_test_cases(asset_uuid)
                # Log the click
                project_data = self.project_dropdown.currentData()
                project_path = self.get_project_path(project_data)
                if project_path:
                    log_file_path = os.path.join(project_path, "click_log.txt")
                    try:
                        with open(log_file_path, 'a', encoding='utf-8') as log_file:
                            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                            asset_name = asset_widget.asset_name
                            log_entry = f"{timestamp} - Asset Name: {asset_name} - UUID: {asset_uuid}\n"
                            log_file.write(log_entry)
                    except Exception as e:
                        print(f"Error writing to log file: {e}")
                else:
                    print("Project path not found, cannot log click.")
        # Optionally handle ScopeItemWidget clicks here

    def load_test_cases(self, asset_uuid, status="All", title_filter=None):
        self.is_updating_filters = True  # Set flag before updating
        self.current_asset_uuid = asset_uuid

        self.test_case_layout.removeWidget(self.test_case_container)
        self.test_case_container = QWidget()
        self.test_case_layout = QVBoxLayout()
        self.test_case_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.test_case_container.setLayout(self.test_case_layout)
        self.test_case_scroll_area.setWidget(self.test_case_container)

        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)

        # Get OTC patterns and set_vault_path at the beginning
        otc_patterns = []
        set_vault_path = None
        if project_path:
            config_path = os.path.join(project_path, "obsidian_config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as config_file:
                    config = json.load(config_file)
                    set_vault_path = config.get("obs_vault_path", "")
                    
            # Get OTC patterns from the selected scope
            selected_item = self.project_tree.currentItem()
            if selected_item and selected_item.parent():
                scope_widget = self.project_tree.itemWidget(selected_item.parent(), 0)
                if isinstance(scope_widget, ScopeItemWidget):
                    selected_file = scope_widget.dropdown.currentText()
                    obs_cd_path = config.get("obs_cd_path", "")
                    if obs_cd_path and selected_file:
                        file_path = os.path.join(obs_cd_path, selected_file)
                        if os.path.exists(file_path):
                            with open(file_path, 'r', encoding='utf-8') as file:
                                content = file.read()
                                import re
                                otc_patterns = re.findall(r'\[\[(.*?)\]\]', content)

        if project_path:
            testcase_path = os.path.join(project_path, "testcase_details.json")
            if os.path.exists(testcase_path):
                with open(testcase_path, 'r') as json_file:
                    testcases = json.load(json_file)
                    if asset_uuid in testcases:
                        # Update title filter dropdown
                        unique_titles = set(tc["title"] for tc in testcases[asset_uuid])
                        current_title = self.title_filter_dropdown.currentText()
                        self.title_filter_dropdown.blockSignals(True)  # Block signals while updating
                        self.title_filter_dropdown.clear()
                        self.title_filter_dropdown.addItem("All")
                        self.title_filter_dropdown.addItems(sorted(unique_titles))
                        if current_title in unique_titles:
                            self.title_filter_dropdown.setCurrentText(current_title)
                        elif title_filter and title_filter in unique_titles:
                            self.title_filter_dropdown.setCurrentText(title_filter)
                        self.title_filter_dropdown.blockSignals(False)  # Unblock signals

                        # Apply filters
                        filtered_test_cases = testcases[asset_uuid]
                        if status != "All":
                            if status == "Unexported":
                                filtered_test_cases = [tc for tc in filtered_test_cases if tc["status"] in ["Pass", "Fail"] and not tc["exported"]]
                            else:
                                filtered_test_cases = [tc for tc in filtered_test_cases if tc["status"] == status]
                        
                        if title_filter and title_filter != "All":
                            filtered_test_cases = [tc for tc in filtered_test_cases if tc["title"] == title_filter]

                        for test_case in filtered_test_cases:
                            test_case_box = QFrame()
                            test_case_box.setFrameShape(QFrame.Shape.Box)
                            test_case_box.setFrameShadow(QFrame.Shadow.Raised)

                            test_case_box_layout = QGridLayout()
                            test_case_box.setLayout(test_case_box_layout)
                            test_case_box_layout.setSpacing(5)
                            test_case_box_layout.setContentsMargins(5, 5, 5, 5)

                            widgets = {}  # Dictionary to hold widgets

                            row = 0
                            excluded_keys = ["uuid", "creation_date", "completed"]
                            keys = [key for key in self.field_order if key in test_case and key not in excluded_keys]
                            for key in keys:
                                value = test_case[key]
                                label_text = self.field_labels.get(key, key.capitalize())
                                label = QLabel(f"{label_text}:")
                                label.setAlignment(Qt.AlignmentFlag.AlignRight)
                                label.setMaximumHeight(25)

                                if key == "title":
                                    combo_box = QComboBox()
                                    combo_box.setEditable(True)
                                    if otc_patterns:
                                        combo_box.addItems(otc_patterns)
                                        completer = QCompleter(otc_patterns)
                                        completer.setFilterMode(Qt.MatchFlag.MatchContains)
                                        completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
                                        combo_box.setCompleter(completer)
                                    combo_box.setCurrentText(value)
                                    combo_box.currentTextChanged.connect(
                                        lambda text, cb=combo_box: self.update_technique_dropdown_in_box(cb, set_vault_path)
                                    )
                                    widgets[key] = combo_box
                                elif key == "technique":
                                    combo_box = QComboBox()
                                    combo_box.setEditable(True)
                                    # Get techniques for the current title
                                    techniques = self.get_techniques_for_title(test_case["title"], set_vault_path)
                                    if techniques:
                                        combo_box.addItems(techniques)
                                    combo_box.setCurrentText(value)
                                    widgets[key] = combo_box

                                elif key == "target_type":
                                    combo_box = QComboBox()
                                    combo_box.addItems(["Module", "URL", "IP", "Service", "File path"])
                                    combo_box.setCurrentText(value)
                                    widgets[key] = combo_box
                                elif key == "status":
                                    combo_box = QComboBox()
                                    combo_box.addItems(["Not started", "Ongoing", "Pass", "Fail"])
                                    combo_box.setCurrentText(value)
                                    widgets[key] = combo_box
                                elif key == "exported" or key == "high_priority":
                                    check_box = QCheckBox()
                                    check_box.setChecked(value)
                                    check_box.test_case_uuid = test_case['uuid']  # Set the UUID property
                                    widgets[key] = check_box
                                elif key == "vuln_group_uuid":
                                    combo_box = QComboBox()
                                    combo_box.addItem("Select Vuln Group")
                                    issues_path = os.path.join(project_path, "issues.json")
                                    if os.path.exists(issues_path):
                                        with open(issues_path, 'r') as json_file:
                                            issues = json.load(json_file)
                                            for group in issues:
                                                combo_box.addItem(group['group_name'], group['uuid'])
                                            # Set the current text based on the vuln_group_uuid
                                            if test_case["vuln_group_uuid"]:
                                                for i in range(combo_box.count()):
                                                    if combo_box.itemData(i) == test_case["vuln_group_uuid"]:
                                                        combo_box.setCurrentIndex(i)
                                                        break
                                            else:
                                                combo_box.setCurrentIndex(0)  # "Select Vuln Group"
                                    widgets[key] = combo_box
                                else:
                                    line_edit = QLineEdit(str(value))
                                    widgets[key] = line_edit
                                test_case_box_layout.addWidget(label, row, 0)
                                test_case_box_layout.addWidget(widgets[key], row, 1)
                                row += 1

                            # Create QHBoxLayout for buttons
                            button_layout = QHBoxLayout()
                            update_button = QPushButton("Update")
                            update_button.clicked.connect(lambda _, tc=test_case, wd=widgets: self.update_test_case(asset_uuid, tc, wd))
                            button_layout.addWidget(update_button)

                            delete_button = QPushButton("Delete")
                            delete_button.clicked.connect(lambda _, tc=test_case: self.delete_test_case(asset_uuid, tc))
                            button_layout.addWidget(delete_button)

                            copy_button = QPushButton("Copy")
                            copy_button.clicked.connect(lambda _, tc=test_case: self.copy_test_case(asset_uuid, tc))
                            button_layout.addWidget(copy_button)

                            up_button = QPushButton("UP")
                            up_button.clicked.connect(lambda _, tc=test_case: self.handle_up_button_click(tc))
                            button_layout.addWidget(up_button)

                            open_note_button = QPushButton("Open note")
                            open_note_button.clicked.connect(lambda _, tc=test_case: self.open_note(tc))
                            button_layout.addWidget(open_note_button)

                            # Add button layout to the grid layout
                            test_case_box_layout.addLayout(button_layout, row, 0, 1, 2)

                            self.test_case_layout.addWidget(test_case_box)
            else:
                QMessageBox.warning(self, "Error", "Test case file not found.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

        self.is_updating_filters = False  # Reset flag after updates are complete
        self.update_button_counts()

    def handle_up_button_click(self, test_case):
        if self.stc_active:
            # Collect all non-empty fields
            fields_to_save = ["title", "technique", "target_type", "target_name",
                              "target_value", "location", "comment", "status",
                              "exported", "high_priority", "vuln_group_uuid"]
            data = {}
            for field in fields_to_save:
                value = test_case.get(field, "")
                if value:
                    data[field] = value
            # Append the data to the list
            self.uuid_list.append(data)
            # Check the "exported" checkbox
            test_case['exported'] = True
            # Update the checkbox in the UI
            for i in range(self.test_case_layout.count()):
                widget = self.test_case_layout.itemAt(i).widget()
                if isinstance(widget, QFrame):
                    for child in widget.children():
                        if isinstance(child, QCheckBox) and child.text() == "Exported":
                            if getattr(child, 'test_case_uuid', None) == test_case['uuid']:
                                child.setChecked(True)
                                break
            # Save the updated test case
            self.save_test_case(test_case, self.current_asset_uuid)
            # Increment counter
            self.stc_counter += 1
            self.stc_counter_label.setText(f"TC Extracted: {self.stc_counter}")
            # Check if we have 5 test cases to write to a file
            if len(self.uuid_list) >= 5:
                self.save_uuids_to_file()

    def save_test_case(self, test_case, asset_uuid):
        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            testcase_path = os.path.join(project_path, "testcase_details.json")
            if os.path.exists(testcase_path):
                with open(testcase_path, 'r') as json_file:
                    testcases = json.load(json_file)
                if asset_uuid in testcases:
                    for tc in testcases[asset_uuid]:
                        if tc['uuid'] == test_case['uuid']:
                            # Update the test case
                            tc.update(test_case)
                            break
                with open(testcase_path, 'w') as json_file:
                    json.dump(testcases, json_file, indent=4)
            else:
                QMessageBox.warning(self, "Error", "Test case file not found.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def save_uuids_to_file(self):
        if self.timestamp_dir:
            file_path = os.path.join(self.timestamp_dir, f"test_cases_{self.current_file_number}.txt")
            with open(file_path, 'w') as f:
                for idx, test_case in enumerate(self.uuid_list, start=1):
                    f.write(f"test case {idx}:\n\n")
                    for key, value in test_case.items():
                        # Skip excluded keys
                        if key in {"status", "exported", "high_priority", "vuln_group_uuid"}:
                            continue
                        
                        # Special handling for target_type
                        if key == "target_type":
                            target_name = test_case.get("target_name", "Unnamed Target")
                            f.write(f"{value}: {target_name}\n")
                        
                        # Rename target_value to target
                        elif key == "target_value":
                            f.write(f"target: {value}\n")
                        
                        # General case for all other keys
                        elif key != "target_name":  # Skip saving target_name explicitly
                            f.write(f"{key}: {value}\n")
                    f.write("\n")
            # Increment file number and clear the list
            self.current_file_number += 1
            self.uuid_list = []

    def get_techniques_for_title(self, title, set_vault_path):
        if not title or not set_vault_path:
            return []
        
        file_name = f"{title}.md"
        for root, dirs, files in os.walk(set_vault_path):
            if file_name in files:
                md_note_file_path = os.path.join(root, file_name).replace("\\", "/")
                if os.path.exists(md_note_file_path):
                    techniques = []
                    inside_techniques = False
                    inside_code_block = False
                    with open(md_note_file_path, "r", encoding="utf-8") as file:
                        for line in file:
                            line = line.strip()
                            if line.startswith("##") and line.lower() == "## techniques":
                                inside_techniques = True
                                continue
                            elif inside_techniques and line.startswith("```"):
                                if inside_code_block:
                                    break
                                else:
                                    inside_code_block = True
                                    continue
                            elif inside_techniques and inside_code_block:
                                techniques.append(line)
                            elif line.startswith("##") and inside_techniques:
                                break
                    return techniques
        return []

    def update_technique_dropdown_in_box(self, title_combo, set_vault_path):
        title = title_combo.currentText()
        # Find the technique combo box in the same test case box
        test_case_box = title_combo.parent()
        for i in range(test_case_box.layout().count()):
            item = test_case_box.layout().itemAt(i)
            if item:
                widget = item.widget()
                if isinstance(widget, QComboBox) and widget != title_combo:
                    label = test_case_box.layout().itemAt(i-1).widget()
                    if label and label.text() == "Technique:":
                        technique_combo = widget
                        technique_combo.clear()
                        techniques = self.get_techniques_for_title(title, set_vault_path)
                        if techniques:
                            technique_combo.addItems(techniques)
                        break

    def open_note(self, test_case):
        # Read obs_vault_path from obsidian_config.json
        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            config_path = os.path.join(project_path, "obsidian_config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as config_file:
                    config = json.load(config_file)
                    obs_vault_path = config.get("obs_vault_path", "")
            else:
                obs_vault_path = None
        else:
            obs_vault_path = None

        if not obs_vault_path:
            QMessageBox.warning(self, "Error", "Obsidian vault path not set.")
            return

        title = test_case.get("title", "")

        # Search for the file in obs_vault_path
        file_name = f"{title}.md"
        note_path = self.find_file(obs_vault_path, file_name)

        if not note_path:
            QMessageBox.warning(self, "Error", f"File '{file_name}' not found in obsidian vault.")
            return

        encoded_note_path = urllib.parse.quote(note_path)

        # Form the URL
        url = f"obsidian://open?path={encoded_note_path}"

        # Open the note in Obsidian
        webbrowser.open(url)

    def find_file(self, directory, filename):
        for root, _, files in os.walk(directory):
            if filename in files:
                return os.path.join(root, filename).replace("\\", "/")
        return None

    def load_vuln_groups(self, project_path):
        issues_path = os.path.join(project_path, "issues.json")
        if os.path.exists(issues_path):
            with open(issues_path, 'r') as json_file:
                issues = json.load(json_file)
            return [issue['group_name'] for issue in issues]
        return []

    def update_test_case(self, asset_uuid, test_case, widgets):
        # Extract the current values from the widgets
        updated_test_case = {
            "uuid": test_case["uuid"],
            "creation_date": test_case["creation_date"],
            "title": widgets["title"].currentText(),  # Use currentText() for QComboBox
            "technique": widgets["technique"].currentText(),  # Use currentText() for QComboBox
            "target_type": widgets["target_type"].currentText(),  # Use currentText() for QComboBox
            "target_name": widgets["target_name"].text(),  # QLineEdit has text()
            "target_value": widgets["target_value"].text(),  # QLineEdit has text()
            "location": widgets["location"].text(),  # QLineEdit has text()
            "comment": widgets["comment"].text(),  # QLineEdit has text()
            "status": widgets["status"].currentText(),  # Use currentText() for QComboBox
            "exported": widgets["exported"].isChecked(),  # QCheckBox has isChecked()
            "high_priority": widgets["high_priority"].isChecked(),  # QCheckBox has isChecked()
            "vuln_group_uuid": widgets["vuln_group_uuid"].currentData(),  # QComboBox has currentData()
            # Update the completed field based on the new status
            "completed": widgets["status"].currentText() in ['Pass', 'Fail']
        }

        # Load the project data and get the project path
        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)

        if project_path:
            issues_path = os.path.join(project_path, "issues.json")
            vuln_group_uuid = updated_test_case.get("vuln_group_uuid", "")
            if vuln_group_uuid:
                if os.path.exists(issues_path):
                    with open(issues_path, 'r') as json_file:
                        issues = json.load(json_file)
                else:
                    issues = []

                # Find the vulnerability group by UUID
                for group in issues:
                    if group.get("uuid") == vuln_group_uuid:
                        test_cases = group.get("test_cases", [])
                        if updated_test_case["uuid"] not in test_cases:
                            test_cases.append(updated_test_case["uuid"])
                            group["test_cases"] = test_cases
                        break

                # Save the updated issues
                with open(issues_path, 'w') as json_file:
                    json.dump(issues, json_file, indent=4)
            else:
                QMessageBox.warning(self, "Error", "No vulnerability group selected.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

        if project_path:
            testcase_path = os.path.join(project_path, "testcase_details.json")
            if os.path.exists(testcase_path):
                with open(testcase_path, 'r') as json_file:
                    testcases = json.load(json_file)

                # Find the index of the test case to update
                if asset_uuid in testcases:
                    for i, tc in enumerate(testcases[asset_uuid]):
                        if tc["uuid"] == test_case["uuid"]:
                            # Update the test case
                            testcases[asset_uuid][i] = updated_test_case
                            break

                    # Save the updated test cases
                    with open(testcase_path, 'w') as json_file:
                        json.dump(testcases, json_file, indent=4)
                    # QMessageBox.information(self, "Success", "Test case updated successfully.")
                    # self.load_test_cases(asset_uuid)
            else:
                QMessageBox.warning(self, "Error", "Test case file not found.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def delete_test_case(self, asset_uuid, test_case):
        confirm = QMessageBox.question(self, "Confirm Delete", "Are you sure you want to delete this test case?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if confirm == QMessageBox.StandardButton.Yes:
            project_data = self.project_dropdown.currentData()
            project_path = self.get_project_path(project_data)
            if project_path:
                testcase_path = os.path.join(project_path, "testcase_details.json")
                if os.path.exists(testcase_path):
                    with open(testcase_path, 'r') as json_file:
                        testcases = json.load(json_file)

                    if asset_uuid in testcases:
                        testcases[asset_uuid] = [tc for tc in testcases[asset_uuid] if tc['uuid'] != test_case['uuid']]

                        with open(testcase_path, 'w') as json_file:
                            json.dump(testcases, json_file, indent=4)
                        QMessageBox.information(self, "Success", "Test case deleted successfully.")
                        self.load_test_cases(asset_uuid)
                else:
                    QMessageBox.warning(self, "Error", "Test case file not found.")
            else:
                QMessageBox.warning(self, "Error", "Project path not found.")

    def copy_test_case(self, asset_uuid, test_case):
        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            testcase_path = os.path.join(project_path, "testcase_details.json")
            if os.path.exists(testcase_path):
                with open(testcase_path, 'r') as json_file:
                    testcases = json.load(json_file)

                # Create a copy of the test case with a new UUID
                new_test_case = {k: v for k, v in test_case.items() if k != "vulnerability"}
                # new_test_case = test_case.copy()
                new_test_case['uuid'] = str(uuid.uuid4())
                new_test_case['creation_date'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                # Append the new test case to the existing list
                if asset_uuid in testcases:
                    testcases[asset_uuid].append(new_test_case)

                # Save the updated test cases
                with open(testcase_path, 'w') as json_file:
                    json.dump(testcases, json_file, indent=4)
                QMessageBox.information(self, "Success", "Test case copied successfully.")
                self.load_test_cases(asset_uuid)
            else:
                QMessageBox.warning(self, "Error", "Test case file not found.")
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def add_vuln_group(self):
        dialog = AddVulnGroupDialog(self)
        dialog.vuln_group_added.connect(self.save_vuln_group)
        dialog.exec()

    def save_vuln_group(self, vuln_group):
        project_data = self.project_dropdown.currentData()
        project_path = self.get_project_path(project_data)
        if project_path:
            issues_path = os.path.join(project_path, "issues.json")
            # Read existing issues
            if os.path.exists(issues_path):
                with open(issues_path, 'r') as json_file:
                    issues = json.load(json_file)
            else:
                issues = []

            issues.append(vuln_group)
            # Save the updated issues
            with open(issues_path, 'w') as json_file:
                json.dump(issues, json_file, indent=4)
            QMessageBox.information(self, "Success", "Vulnerability group added successfully.")

            # Refresh the test case boxes to load the new vulnerability group
            self.refresh_test_case_boxes()
        else:
            QMessageBox.warning(self, "Error", "Project path not found.")

    def refresh_test_case_boxes(self):
        # Get the currently selected asset UUID
        selected_item = self.project_tree.currentItem()
        if selected_item:
            asset_widget = self.project_tree.itemWidget(selected_item, 0)
            if asset_widget:
                asset_uuid = asset_widget.asset_data.get('uuid', None)
                if asset_uuid:
                    self.load_test_cases(asset_uuid)

    def get_project_path(self, project_data):
        projects_dir = "projects"
        project_name = project_data.get("project_name")
        for project_dir in os.listdir(projects_dir):
            project_path = os.path.join(projects_dir, project_dir)
            if os.path.isdir(project_path) and os.path.exists(os.path.join(project_path, "project_details.json")):
                with open(os.path.join(project_path, "project_details.json"), 'r') as json_file:
                    data = json.load(json_file)
                    if data.get("project_name") == project_name:
                        return project_path
        return None

class ScopeItemWidget(QWidget):
    def __init__(self, scope_name, scope_data, parent_widget):
        super().__init__()
        self.scope_name = scope_name
        self.scope_data = scope_data  # Contains 'type', 'name', 'value'
        self.parent_widget = parent_widget  # Reference to MainWindow

        layout = QHBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.setLayout(layout)

        self.label = QLabel(f"{self.scope_name}")
        layout.addWidget(self.label)

        # Dropdown list for files in obs_cd_path
        self.dropdown = QComboBox()
        self.dropdown.setFixedWidth(200)  # Adjust width as needed
        self.populate_dropdown()
        layout.addWidget(self.dropdown)

        # Save the selected value when it changes
        self.dropdown.currentIndexChanged.connect(self.save_selected_value)

        self.setFixedHeight(24)

    def populate_dropdown(self):
        project_data = self.parent_widget.project_dropdown.currentData()
        project_path = self.parent_widget.get_project_path(project_data)
        if project_path:
            config_path = os.path.join(project_path, "obsidian_config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as config_file:
                    config = json.load(config_file)
                    obs_cd_path = config.get("obs_cd_path", "")
                    if os.path.exists(obs_cd_path):
                        files = [f for f in os.listdir(obs_cd_path) if os.path.isfile(os.path.join(obs_cd_path, f))]
                        self.dropdown.addItems(files)
                        # Set the current text to the saved value if available
                        saved_value = self.scope_data.get("selected_file", "")
                        if saved_value in files:
                            self.dropdown.setCurrentText(saved_value)
                        return
        self.dropdown.addItem("No files found")

    def save_selected_value(self, index):
        selected_file = self.dropdown.currentText()
        project_data = self.parent_widget.project_dropdown.currentData()
        project_path = self.parent_widget.get_project_path(project_data)
        if project_path:
            # Find the index of the current scope in project_data["scopes"]
            for i, scope in enumerate(project_data["scopes"]):
                if scope == self.scope_data:
                    project_data["scopes"][i]["selected_file"] = selected_file
                    break
            # Save the updated project_data to project_details.json
            with open(os.path.join(project_path, "project_details.json"), 'w') as json_file:
                json.dump(project_data, json_file, indent=4)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())